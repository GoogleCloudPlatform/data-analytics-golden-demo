####################################################################################
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
####################################################################################
import os
import json
import data_analytics_agent.rest_api_helper as rest_api_helper
import data_analytics_agent.gemini.gemini_helper as gemini_helper
import data_analytics_agent.knowledge_engine.knowledge_engine as knowledge_engine_helper
import logging
import re
# import asyncio # New: # import asyncio for if needed in this module (though not directly for derive_business_glossary_from_knowledge_engine)
# The `wait_tool` is not used directly in this file's functions, but it's part of the agent's playbook logic.

logger = logging.getLogger(__name__)


knowledge_engine_business_glossary_instruction="""You are a specialized, **Knowledge Engine that can create Business Glossaries**, designed to create 
and populate a Google Dataplex Business Glossary, including its categories and terms. Your core capability is to leverage the output of a Dataplex Knowledge Engine 
scan for intelligent categorization and detailed term population, without requiring any interactive clarification from the user once initiated.

You will respond to prompts like "Create a business glossary for my dataset" or "Create a business glossary based upon my knowledge engine scan".

Your process relies entirely on interpreting the initial request, utilizing your tools, and employing internal heuristics to drive the glossary creation.

**Available Tools (You MUST only call functions from this list):**
*   `get_knowledge_engine_scans() -> dict`:
    *   **Description:** Lists all Dataplex Knowledge Engine scans in the configured region.
    *   **Returns:** A dictionary containing a list of knowledge engine scan objects.
*   `get_knowledge_engine_scans_for_dataset(dataset_id: str) -> dict`:
    *   **Description:** Lists all Dataplex Knowledge Engine scans that are configured to scan a specific BigQuery dataset.
    *   **Args:** `dataset_id` (str): The ID (or name) of the BigQuery dataset.
    *   **Returns:** A dictionary containing a list of knowledge engine scan objects.
*   `get_knowledge_engine_scan(knowledge_engine_scan_name: str) -> dict`: Retrieves the full details of a specified Dataplex Knowledge Engine scan, including its derived business glossary terms and schema relationships.
    *   **Returns:** A dictionary containing the detailed scan object.
*   `create_business_glossary(glossary_id: str, display_name: str, description: str = "") -> dict`: Creates a new Dataplex Business Glossary. This tool performs an internal check to see if the glossary already exists. If it exists, the existing glossary will be used, and the tool will return a success status indicating reuse.
    *   **Returns:** A dictionary indicating the creation/reuse status and details.
*   `get_business_glossary(glossary_id: str) -> dict`: Retrieves the full, detailed configuration and status of a specific Dataplex Business Glossary.
    *   **Returns:** A dictionary containing the detailed glossary object.
*   `derive_business_glossary_from_knowledge_engine(knowledge_engine_scan_name: str) -> dict`: **(LLM-driven Tool)** Internally retrieves terms from the specified Knowledge Engine scan. It then uses an internal LLM to suggest 2-10 distinct categories and classifies each term from the scan into one of these categories. The `term_id` generated by this tool will be a kebab-case identifier, sanitized to be suitable for Dataplex term IDs (alphanumeric, hyphens only).
    *   **Args:** `knowledge_engine_scan_name` (str): The short name/ID of the knowledge engine scan.
    *   **Returns:** A dictionary containing the status and a structured `results` object with two lists: `categories` and `terms`.
    *   **Return Structure (within `results`):**
        ```json
        {
            "categories": [
                {"category_id": "kebab-case-id", "display_name": "Display Name", "description": "Category description"},
                ...
            ],
            "terms": [
                 {"term_id": "kebab-case-id-sanitized", "term_title": "Term Title", "term_description": "Term Description", "category_id": "category-id"},
                 ...
            ]
        }
        ```
*   `create_business_glossary_category(glossary_id: str, category_id: str, display_name: str, description: str = "") -> dict`: Creates a new category within a specified Dataplex Business Glossary. This tool performs an internal check to see if the category already exists within the glossary. If it exists, the existing category will be used, and the tool will return a success status indicating reuse.
    *   **Returns:** A dictionary indicating the creation/reuse status and details.
*   `get_business_glossary_category(glossary_id: str, category_id: str) -> dict`: Retrieves the full details of a specific Dataplex Business Glossary category.
    *   **Returns:** A dictionary containing the detailed category object.
*   `create_business_glossary_term(glossary_id: str, term_id: str, display_name: str, description: str = "", parent_category_id: str = None) -> dict`: Creates a new term within a Dataplex Business Glossary, optionally nested under a specific category. This tool performs an internal existence check. If the term already exists, it will report that it exists but *will not* update it.
    *   **Returns:** A dictionary indicating the creation status and details.
*   `get_business_glossary_term(glossary_id: str, term_id: str) -> dict`: Retrieves the full details of a specific Dataplex Business Glossary term.
    *   **Returns:** A dictionary containing the detailed term object.
*   `update_business_glossary_term(glossary_id: str, term_id: str, display_name: str, description: str) -> dict`: Updates an existing Dataplex Business Glossary term, allowing modification of its display name and/or description.
    *   **Returns:** A dictionary indicating the update status and results.
*   `get_bigquery_dataset_list() -> dict`: Gets the datasets in BigQuery. You should call this to get the dataset_id based on the name the user provided. Do not trust the name provided.
    *   **Returns:** A dictionary indicating the update status and results.


**Your Operational Playbook (You MUST follow this sequence):**
Whenever a step cannot be completed autonomously due to missing data, ambiguity, or tool failure, you MUST generate a detailed, structured failure report to the coordinator, explaining precisely why the task cannot be fulfilled and which step failed. Your communication is strictly outputs of successful tasks or detailed failure reports.

**Input Parameters for this Sub-Agent:**
When this sub-agent is invoked, it will receive the following parameters:
*   `dataset_id` (str) or `knowledge_engine_scan_name` (str): The dataset that has the knowledge scan or the knowledge engine scan name.
*   `glossary_display_name` (str, optional): The user-friendly display name for the glossary. If not provided, you will derive a default name from the `knowledge_engine_scan_name` or `dataset_id`.
*   `glossary_description` (str, optional): The description for the glossary. If not provided, you will derive a default description based on the `knowledge_engine_scan_name` or `dataset_id` and the general purpose.

**Step 1: Determine input type**
*   If the input is a `dataset_id`, call the tool `get_bigquery_dataset_list` to get the dataset_id based on the name the user provided.  
    *    Then call `get_knowledge_engine_scans_for_dataset(dataset_id)`. If this returns exactly one scan, proceed with that scan's `name` as `knowledge_engine_scan_name`. If it returns zero or more than one scan, generate a detailed failure report, indicating the ambiguity or absence of a unique scan.
*   If the input is a `knowledge_engine_scan_name`, call the tool `get_knowledge_engine_scan(knowledge_engine_scan_name)` to retrieve its details. If the scan is not found, generate a failure report. Extract the BigQuery `dataset_id` from the `resource` field within the `data` object (e.g., from `data.resource` which looks like `//bigquery.googleapis.com/projects/project-id/datasets/dataset-id`, extract the last segment).
*   Use the extracted `dataset_id` for the `glossary_id` (replace underscores with dashes/hyphens).
*   Use the extracted `dataset_id` for the `determined_display_name` (replace underscores with spaces and make proper case).
*   Use the extracted `dataset_id` for the `determined_description` (replace underscores with spaces and make proper case).

**Step 2: Retrieve Business Terms from Knowledge Engine Scan (Data Source)**
*   Call `get_knowledge_engine_scan(knowledge_engine_scan_name)`. Store the full result as `knowledge_scan_results`.
*   **Self-Correction:** If the scan is not found immediately generate a failure report, stating that terms could not be extracted.

**Step 3: Create or Reuse the Main Business Glossary (Foundation)**
*   Call `create_business_glossary(glossary_id, determined_display_name, determined_description)`. This tool will create the glossary if it doesn't exist, or use the existing one.
*   **Self-Correction:** If the `create_business_glossary` call returns a "status" of "failed" for any reason (e.g., underlying API error), generate a failure report. 

**Step 4: Derive and Create or Reuse Business Glossary Categories and Terms (Structure and Content Creation - LLM Driven)**
*   Call `derive_business_glossary_from_knowledge_engine(knowledge_engine_scan_name)`. Store the full result as `derived_glossary_data`.
*   **Self-Correction:** If `derived_glossary_data` returns a "status" of "failed" or fails to contain valid `categories` or `terms` in its `results`, generate a failure report, indicating that LLM-driven glossary derivation failed.
*   Initialize an empty list `created_category_ids`.
*   Iterate through each `category_item` object in `derived_glossary_data.results.categories`:
    *   Call `create_business_glossary_category(glossary_id, category_item['category_id'], category_item['display_name'], category_item['description'])`. This tool will create the category if it doesn't exist, or use the existing one.
    *   **Self-Correction (Per Category):** If a category creation/reuse fails (e.g., due to API error), record the failure in messages but *attempt to continue* with other categories and terms if possible. Only if *all* category creations fail, should this step be marked as a complete failure. Add the successfully created `category_id` to `created_category_ids`.
*   **Final Check for Categories:** If `created_category_ids` is empty after this step, generate a failure report, as terms cannot be categorized without them.

**Step 5: Create Business Glossary Terms (Content Population - Simplified)**
*   Initialize an empty list `terms_creation_status`.
*   For each `term_item` (each dictionary with "term_id", "term_title", "term_description", and "category_id") in the `derived_glossary_data.results.terms` list obtained in Step 4:
    *   Use `term_item['term_id']` as the `term_id`.
    *   Use `term_item['term_title']` as the `display_name`.
    *   Use `term_item['term_description']` as the `description`.
    *   Use `term_item['category_id']` as the `parent_category_id`.
    *   **Attempt to Create Term:**
        *   Call `create_business_glossary_term(glossary_id, term_id, display_name, description, parent_category_id=parent_category_id)`.
        *   Record the result in `terms_creation_status`. Note that if a term already exists, this tool will report it as existing but **will not update its details**. If updating existing terms is desired, the `create_business_glossary_term` tool itself would need modification or a separate `update` call would be necessary in the playbook.
        *   If the `create_business_glossary_term` call returns a "status" of "failed" for any reason, record this as a failure to process the term.

**Step 6: Report Comprehensive Results (Summary)**
*   If all steps executed without critical failure, return a "success" status.
*   Provide a summary of the operations, including:
    *   The `glossary_id` and `display_name` of the created/used glossary.
    *   A list of all categories that were successfully created/used, including their IDs and display names.
    *   A count of terms processed, successfully created (or found to exist), and any that failed creation.
    *   Any specific warnings or messages accumulated during the process (e.g., terms that couldn't be classified or created).
*   If any critical step failed, return a "failed" status with a detailed explanation in the `messages` field, pinpointing the exact step and reason for failure.

---

**Security and Safety Guardrails:**

*   **WRITE OPERATIONS ALLOWED:** Unlike a read-only agent, this agent is explicitly authorized to perform **write operations** (CREATE, UPDATE) for Dataplex Glossaries, Categories, and Terms.
*   **TOOL RELIANCE:** You MUST NOT invent tool names, API endpoints, or parameters. Rely **EXCLUSIVELY** on calling the functions listed in the "Available Tools" section. All data and parameters MUST derive from information *returned by those tools*, direct inputs to this sub-agent, or robust internal derivations (e.g., kebab-case conversion).
*   **FAILURE REPORTING:** If any step cannot be completed autonomously, you MUST generate a clear, concise, and structured failure report. This report should include:
    *   `status: "failed"`
    *   `messages: ["Specific reason for failure.", "Any relevant tool messages."]`
    *   `debug_info: { ... }` (Optional: provide internal state/tool outputs leading to failure for debugging by coordinator).
*   **NO INTERACTION:** You are an autonomous sub-agent. You **MUST NOT** ask clarifying questions. Your communication is strictly through structured outputs (success reports or detailed failure reports).
"""


def derive_business_glossary_from_knowledge_engine(knowledge_engine_scan_name: str) -> dict: # Changed to def
    """
    Creates a list of categories for a business glossary based upon a knowledge engine scan. Also,
    places each term in the respective category. Ensures term_id and term_title (display_name)
    adhere to Dataplex naming conventions.

    Args:
        knowledge_engine_scan_name (str): The short name/ID of the knowledge engine scan.

    Returns:
        dict: A dictionary containing the status and the list of suggested categories and classified terms.
        {
            "status": "success" or "failed",
            "tool_name": "derive_business_glossary_from_knowledge_engine",
            "query": None,
            "messages": ["List of messages during processing"],
            "results": {
                "categories": [
                    {
                       "category_id": "kebab-case-id", 
                       "display_name": "Display Name",
                       "description": "Category description"
                    }
                ],
                "terms": [
                     {
                    "term_id" : "kebab-case-id",
                    "term_title" : "Sanitized Term Title",
                    "term_description" : "Term Description",
                    "category_id" : "category_id"
                    }               
                ]
            }
        }
    """
    response =  {
            "status": "success",
            "tool_name": "derive_business_glossary_from_knowledge_engine",
            "query": None,
            "messages": [],
            "results": None
        }

    # the call to knowledge_engine_helper.get_knowledge_engine_scan
    get_knowledge_engine_scan_response = knowledge_engine_helper.get_knowledge_engine_scan(knowledge_engine_scan_name)

    if get_knowledge_engine_scan_response["status"] == "failed":
        response["status"] = "failed"
        response["messages"].extend(get_knowledge_engine_scan_response["messages"])
        response["messages"].append(f"Failed to get knowledge engine scan of {knowledge_engine_scan_name} from tool: get_knowledge_engine_scan")
        return response
    
    suggested_terms = get_knowledge_engine_scan_response.get("results", {}).get("knowledgeEngineResult", {}).get("datasetResult", {}).get("businessGlossary", {}).get("terms", [])

    if not suggested_terms:
        response["status"] = "failed"
        response["messages"].append("No business glossary terms found in the knowledge scan results to derive categories from.")
        return response

    # Format terms for the LLM prompt
    formatted_terms = "\n".join([f"- Title: {t['title']}, Description: {t['description']}" for t in suggested_terms])

    prompt = f"""You are an expert in data governance and business glossary creation.
    Based on the following list of business terms and their descriptions, propose 2 to 10 distinct business glossary categories.
    Then place each term into their perspective category.
    Each term should be in one and only one category.
    You must classify every term into a category.

    Each category should have:
    1.  A 'category_id' (string): A unique, kebab-case identifier (e.g., "sales-operations", "customer-data").
    2.  A 'display_name' (string): A user-friendly name. The first and last character cannot be a space.
    3.  A 'description' (string): A brief explanation of what terms would belong to this category.
    4.  A 'terms' (array): A list of term title's that apply for the category id.

    Here are the terms:
    {formatted_terms}
    """

    # Define the response schema for the LLM
    category_schema = {
        "type": "array",
        "items": {
            "type": "object",
            "properties": {
                "category_id": {"type": "string", "description": "Unique, kebab-case identifier for the category."},
                "display_name": {"type": "string", "description": "A user-friendly name. The first and last character cannot be a space."},
                "description": {"type": "string", "description": "Brief description of the category."},
                "terms": {"type": "array", "description": "The terms that belong to this category.", "items": {"type": "string"} }
            },
            "required": ["category_id", "display_name", "description", "terms"]
        }
    }

    try:
        # the call to gemini_helper.gemini_llm
        gemini_response = gemini_helper.gemini_llm(prompt, response_schema=category_schema, model="gemini-2.5-flash", temperature=0.2)
        gemini_response_dict = json.loads(gemini_response)

        categories_response = []
        terms_response = []

        for item in gemini_response_dict: 
            # Sanitize category display name as well, as LLMs might not always adhere strictly
            clean_category_display_name = re.sub(r'[^\w\s-]', '', item["display_name"]).strip()
            clean_category_display_name = re.sub(r'\s+', ' ', clean_category_display_name) # Replace multiple spaces with single space

            category_item = {
                "category_id": item["category_id"], # category_id should already be kebab-case from LLM prompt
                "display_name": clean_category_display_name,
                "description": item["description"],
            }
            
            # Basic client-side validation for stricter adherence
            if all(c.isalnum() or c in [' ', '_', '-'] for c in category_item['display_name']) and \
               not category_item['display_name'].startswith(' ') and not category_item['display_name'].endswith(' '):
                categories_response.append(category_item)
            else:
                response["messages"].append(f"Warning: Sanitized category display name '{category_item['display_name']}' for category_id '{category_item.get('category_id')}' still violates strict naming rules. Skipping category.")


            for term_title_raw in item["terms"]:
                # Sanitize term_id (kebab-case)
                # Remove non-alphanumeric, convert spaces/hyphens to single hyphen, lowercase
                sanitized_term_id = re.sub(r'[^\w\s-]', '', term_title_raw).lower()
                sanitized_term_id = re.sub(r'[\s_]+', '-', sanitized_term_id).strip('-')

                # Sanitize term_title (display_name)
                # Remove parentheses, commas, ampersands, and ensure proper spaces
                clean_term_title = re.sub(r'[^\w\s-]', '', term_title_raw).strip() # Remove non-alphanumeric except space/hyphen, then strip leading/trailing spaces
                clean_term_title = re.sub(r'\s+', ' ', clean_term_title) # Replace multiple spaces with single space
                clean_term_title = clean_term_title.replace(',', '').replace('&', '') # Explicitly remove commas and ampersands
                
                # Check for leading/trailing spaces again after all replacements
                if clean_term_title.startswith(' ') or clean_term_title.endswith(' '):
                    clean_term_title = clean_term_title.strip()


                term_description = get_term_description(get_knowledge_engine_scan_response, term_title_raw) # Use original raw title to find description

                term_item = {
                    "term_id" : sanitized_term_id,
                    "term_title" : clean_term_title, # Use the sanitized display name
                    "term_description" : term_description,
                    "category_id" : item["category_id"]
                }

                # Only add if the display name is valid after all sanitization
                if clean_term_title and all(c.isalnum() or c in [' ', '_', '-'] for c in clean_term_title) and \
                   not clean_term_title.startswith(' ') and not clean_term_title.endswith(' '):
                    terms_response.append(term_item)
                else:
                    response["messages"].append(f"Warning: Sanitized term title '{clean_term_title}' for original term '{term_title_raw}' violates strict naming rules. Skipping term creation for this term.")

        response["results"] = {
            "categories" : categories_response,
            "terms" : terms_response # Removed [:10] for production
        }
        response["messages"].append(f"Successfully derived {len(categories_response)} categories and {len(terms_response)} terms after sanitization.")
        return response
    
    except Exception as e:       
        response["status"] = "failed"
        response["messages"].append(f"An error occurred while deriving categories and terms using LLM: {e}")
        return response


# Helper function, not a tool
def get_term_description(get_knowledge_engine_scan_response: str, term_title_to_find: str) -> str:
    """
    Retrieves the description of a term from the knowledge engine response
    based on its title.

    Args:
        get_knowledge_engine_scan_response (dict): The full response dictionary from the knowledge engine scan.
        term_title_to_find (str): The title of the term whose description is needed.

    Returns:
        str or None: The description of the term if found, otherwise None.
    """
    try:
        terms_array = get_knowledge_engine_scan_response["results"]["knowledgeEngineResult"]["datasetResult"]["businessGlossary"]["terms"]

        # Iterate through the list of term dictionaries
        for term in terms_array:
            if term.get("title") == term_title_to_find:
                return term.get("description")
        
        # If the loop finishes, the term was not found
        return None

    except KeyError as e:
        logger.error(f"Error: Missing key in response data: {e}") 
        return None
    except TypeError:
        logger.error("Error: Invalid response data structure. 'terms' might not be an array or other keys are missing.") # Using logger.error instead of print
        return None